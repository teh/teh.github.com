{"version":3,"sources":["App.tsx","index.tsx"],"names":["unreachable","e","Error","mkVar","name","kind","mkLiteral","value","varCounter","freshVar","stack","mkHeap","nil","tag","payload","zero","one","two","three","plusInt","arguments","expression","alternatives","bindingName","a1","a2","newObject","in","foldl","f","sum","list1","list2","list3","main","heap","substitute","old","newAtom","substituteVar","v","substituteAtom","substituteLiteral","map","alt","substituteObject","obj","x","enter","stackTop","length","undefined","pop","lit","exp","console","log","h","t","var","push","i","slice","p","atomPrettyPrint","a","toString","heapPrettyPrint","key","join","expressionPrettyPrint","App","useState","step","setStep","splice","keyPress","useEffect","window","addEventListener","removeEventListener","className","aria-label","role","href","cont","branch","y","stackPrettyPrint","Object","keys","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.3ae42999.chunk.js","sourcesContent":["// TODO\n// better pretty printing for\n// * CaseCont\n// * maybe \"unroll\" the entire program?\n\nimport React, { useState, useEffect } from 'react';\nimport './App.css';\n// import { notStrictEqual } from 'assert';\n\n\nfunction unreachable(e: never): never {\n  throw new Error(\"unreachable\");\n}\n\ninterface FUN {\n  kind: \"FUN\",\n  arguments: Atom[],\n  expression: Expression,\n}\n\ninterface CON {\n  kind: \"CON\",\n  tag: \"Nil\" | \"Cons\" | \"I\"; // lists and ints\n  payload: any[],\n}\n\ninterface PAP {\n  kind: \"PAP\",\n  f: Var,\n  arguments: Atom[],\n}\n\ninterface THUNK {\n  kind: \"THUNK\",\n  expression: Expression,\n}\n\ninterface BLACKHOLE {\n  kind: \"BLACKHOLE\",\n}\n\ninterface FunctionApply {\n  kind: \"FunctionApply\",\n  f: Var, // lookup on heap\n  arguments: Atom[],\n}\n\ninterface Case {\n  kind: \"Case\",\n  expression: Expression,\n  alternatives: Alternative[],\n}\n\ninterface Alternative {\n  kind: \"Alternative\",\n  tag: \"Cons\" | \"Nil\" | \"I\" | \"default\",\n  bindingName: Atom[],\n  expression: Expression,\n}\n\ninterface Let {\n  kind: \"Let\",\n  newObject: HeapObject,\n  name: string,\n  in: Expression,\n}\ninterface PrimPlus {\n  kind: \"PrimPlus\",\n  a1: Literal,\n  a2: Literal,\n}\ninterface Var {\n  kind: \"Var\",\n  name: string,\n}\n\ninterface Literal {\n  kind: \"Literal\",\n  name: string,\n  value: number,\n}\n\ninterface CaseCont {\n  kind: \"CaseCont\",\n  alternatives: Alternative[],\n}\ninterface UpdateCont {\n  kind: \"UpdateCont\",\n  var: Var,\n}\ninterface ApplyToArgs {\n  kind: \"ApplyToArgs\",\n  arguments: Atom[],\n}\n\nconst mkVar = (name: string): Var => ({ kind: \"Var\", name });\nconst mkLiteral = (name: string): Literal => ({ kind: \"Literal\", name, value: 0 });\n\nlet varCounter = 0;\nconst freshVar = (): Var => {\n  return { kind: \"Var\", name: `$${varCounter++}` }\n}\n\nexport type HeapObject = FUN | CON | PAP | THUNK | BLACKHOLE;\nexport type Expression = FunctionApply | Case | Let | PrimPlus | Atom;\nexport type Continuation = CaseCont | UpdateCont | ApplyToArgs;\nexport type Atom = Literal | Var;\n\nconst stack: Continuation[] = [];\n\n\nexport const mkHeap = (): Record<string, HeapObject> => ({\n  nil: { kind: \"CON\", tag: \"Nil\", payload: [] },\n  zero: { kind: \"CON\", tag: \"I\", payload: [{ kind: \"Literal\", name: \"-\", value: 0 }] },\n  one: { kind: \"CON\", tag: \"I\", payload: [{ kind: \"Literal\", name: \"-\", value: 1 }] },\n  two: { kind: \"CON\", tag: \"I\", payload: [{ kind: \"Literal\", name: \"-\", value: 2 }] },\n  three: { kind: \"CON\", tag: \"I\", payload: [{ kind: \"Literal\", name: \"-\", value: 3 }] },\n\n  plusInt: {\n    kind: \"FUN\", arguments: [mkVar(\"x\"), mkVar(\"y\")], expression: {\n      kind: \"Case\", expression: mkVar(\"x\"),\n      alternatives: [{\n        kind: \"Alternative\", tag: \"I\", bindingName: [mkLiteral(\"i\")], expression: {\n          kind: \"Case\", expression: mkVar(\"y\"),\n          alternatives: [{\n            kind: \"Alternative\", tag: \"I\", bindingName: [mkLiteral(\"j\")], expression: {\n              kind: \"Case\", expression: { kind: \"PrimPlus\", a1: mkLiteral(\"i\"), a2: mkLiteral(\"j\") },\n              alternatives: [{\n                kind: \"Alternative\",\n                tag: \"default\",\n                bindingName: [mkVar(\"result\")],\n                expression: {\n                  kind: \"Let\", name: \"value\",\n                  newObject: { kind: \"CON\", tag: \"I\", payload: [mkVar(\"result\")] },\n                  in: mkVar(\"value\")\n                },\n              }]\n            }\n          }]\n        }\n      }]\n    }\n  },\n  foldl: {\n    kind: \"FUN\", arguments: [mkVar(\"f\"), mkVar(\"acc\"), mkVar(\"list\")], expression: {\n      kind: \"Case\", expression: mkVar(\"list\"),\n      alternatives: [\n        { kind: \"Alternative\", tag: \"Nil\", bindingName: [], expression: mkVar(\"acc\") },\n        {\n          kind: \"Alternative\", tag: \"Cons\", bindingName: [mkVar(\"h\"), mkVar(\"t\")], expression: {\n            kind: \"Let\", name: \"newAcc\", newObject: {\n              kind: \"THUNK\", expression: {\n                kind: \"FunctionApply\", f: mkVar(\"f\"),\n                arguments: [mkVar(\"acc\"), mkVar(\"h\")]\n              },\n            }, in: {\n              kind: \"FunctionApply\", f: mkVar(\"foldl\"), arguments: [mkVar(\"f\"), mkVar(\"newAcc\"), mkVar(\"t\")],\n            }\n          },\n        },\n      ]\n    }\n  },\n  // # lazy sum with a well-known space leak\n  sum: {\n    kind: \"FUN\", arguments: [mkVar(\"list\")], expression: {\n      kind: \"FunctionApply\", f: mkVar(\"foldl\"), arguments: [mkVar(\"plusInt\"), mkVar(\"zero\"), mkVar(\"list\")],\n    }\n  },\n  list1: { kind: \"CON\", tag: \"Cons\", payload: [mkVar(\"one\"), mkVar(\"nil\")] },\n  list2: { kind: \"CON\", tag: \"Cons\", payload: [mkVar(\"two\"), mkVar(\"list1\")] },\n  list3: { kind: \"CON\", tag: \"Cons\", payload: [mkVar(\"three\"), mkVar(\"list2\")] },\n  main: {\n    kind: \"THUNK\", expression: { kind: \"FunctionApply\", f: mkVar(\"sum\"), arguments: [mkVar(\"list3\")] },\n  }\n})\nexport let heap = mkHeap();\n\n\n\nexport const substitute = (e: Expression, old: Atom, newAtom: Atom): Expression => {\n  const substituteVar = (v: Var): Var => v.name === old.name ? (newAtom as Var) : v;\n  const substituteAtom = (v: Atom): Atom => v.name === old.name ? newAtom : v;\n  const substituteLiteral = (v: Literal): Literal => v.name === old.name ? (newAtom as Literal) : v;\n\n  const substituteObject = (obj: HeapObject): HeapObject => {\n    switch (obj.kind) {\n      case \"THUNK\": {\n        return { kind: obj.kind, expression: substitute(obj.expression, old, newAtom) }\n      }\n      case \"CON\": {\n        return { kind: obj.kind, tag: obj.tag, payload: obj.payload.map(x => substituteAtom(substituteObject(x) as any)) }\n      }\n      case \"FUN\": {\n        return { kind: obj.kind, arguments: obj.arguments, expression: substitute(obj.expression, old, newAtom) }\n      }\n      case \"PAP\": {\n        return {\n          kind: obj.kind,\n          f: substituteVar(obj.f),\n          arguments: obj.arguments.map(x => substituteAtom(x)),\n        }\n      }\n    }\n    return obj;\n  };\n\n  switch (e.kind) {\n    case \"FunctionApply\": {\n      return {\n        kind: e.kind,\n        f: substituteVar(e.f),\n        arguments: e.arguments.map(substituteAtom)\n      }\n    }\n    case \"Case\": {\n      // need to walk all Alt branches\n      return {\n        kind: e.kind,\n        expression: substitute(e.expression, old, newAtom),\n        alternatives: e.alternatives.map(alt => ({\n          kind: \"Alternative\",\n          tag: alt.tag,\n          expression: substitute(alt.expression, old, newAtom),\n          bindingName: alt.bindingName,\n        })),\n      }\n    }\n    case \"Let\": {\n      return {\n        kind: e.kind,\n        in: substitute(e.in, old, newAtom),\n        newObject: substituteObject(e.newObject),\n        name: e.name, // What about shadowing names?\n      }\n    }\n    case \"Var\": {\n      if (e.name === old.name) {\n        return newAtom\n      }\n      return e;\n    }\n    case \"PrimPlus\": {\n      return { kind: e.kind, a1: substituteLiteral(e.a1), a2: substituteLiteral(e.a2) };\n    }\n    case \"Literal\": {\n      throw new Error(\"literal can't be substituted\")\n    }\n  }\n  unreachable(e);\n}\n\n\nexport const enter = (e: Expression): Expression | null => {\n  switch (e.kind) {\n    case \"Literal\": {\n      const stackTop = stack[stack.length - 1];\n      if (stackTop !== undefined && stackTop.kind === \"CaseCont\") {\n        stack.pop();\n        const alt = stackTop.alternatives[0]\n        if (alt && alt.tag === \"default\") {\n          const lit = mkLiteral(alt.bindingName[0].name);\n          lit.value = e.value;\n          let exp = substitute(alt.expression, alt.bindingName[0], lit);\n          console.log(\"SUBST\", exp)\n          return exp;\n        }\n      }\n      throw new Error(\"no default literal case alternative\");\n    }\n    case \"Var\": {\n      const obj = heap[e.name];\n      switch (obj.kind) {\n        case \"FUN\":\n          console.log(\"--- FUN\")\n          return e;\n        case \"PAP\":\n          console.log(\"--- PAP\")\n          return e;\n        case \"CON\":\n          const stackTop = stack[stack.length - 1];\n          if (stackTop !== undefined && stackTop.kind === \"CaseCont\") {\n            stack.pop();\n            console.log(\"stackTop.alternatives\", stackTop.alternatives[0])\n            for (let alt of stackTop.alternatives) {\n              // find matching tag branch\n              if (alt.tag !== obj.tag) { continue }\n              switch (alt.tag) {\n                case \"Nil\": {\n                  return alt.expression\n                }\n                case \"Cons\": {\n                  const h = obj.payload[0];\n                  const t = obj.payload[1];\n                  let exp = substitute(alt.expression, alt.bindingName[0], h)\n                  exp = substitute(exp, alt.bindingName[1], t)\n                  return exp;\n                }\n                case \"I\": {\n                  // replace variables with literal\n                  return substitute(\n                    alt.expression,\n                    alt.bindingName[0],\n                    { kind: \"Literal\", name: alt.bindingName[0].name, value: obj.payload[0].value }\n                  )\n                }\n              }\n            } // end initial for\n            for (let alt of stackTop.alternatives) {\n              if (alt.tag === \"default\") {\n                console.log(\"default case\")\n                return alt.expression;\n              }\n            }\n          } else if (stackTop !== undefined && stackTop.kind === \"UpdateCont\") {\n            stack.pop();\n            console.log(\"stack\\n\", stack)\n            console.log(\"stackTop.update-var\", stackTop.var, \"with\", e.name);\n            heap[stackTop.var.name] = heap[e.name];\n            return e;\n          }\n          return null;\n        case \"THUNK\":\n          console.log(\"THUNK\", e)\n          heap[e.name] = { kind: \"BLACKHOLE\" };\n          stack.push({ kind: \"UpdateCont\", var: e });\n          return obj.expression;\n        case \"BLACKHOLE\":\n          throw new Error(\"loopy\");\n      }\n      throw new Error(\"unhandled\");\n    }\n    case \"PrimPlus\": {\n      // TODO - this isn't really a primop in the paper sense because I'm heap-allocating.\n      const lit = mkLiteral(\"-\");\n      lit.value = e.a1.value + e.a2.value;\n      return lit;\n    }\n    case \"Let\": {\n      // heap alloc, substitute, enter expression\n      const v = freshVar();\n      heap[v.name] = e.newObject;\n      return substitute(e.in, mkVar(e.name), v);\n    }\n    case \"FunctionApply\": {\n      if (e.f.kind === \"Var\") {\n        // console.log(\"H\", `\"${e.f.name}\"`, heap)\n        const obj = heap[e.f.name];\n        switch (obj.kind) {\n          case \"FUN\": {\n            console.log(\"FUN\", obj.arguments.length, e.arguments.length)\n            if (obj.arguments.length === e.arguments.length) {\n\n              let exp: Expression = obj.expression;\n              for (let i = 0; i < obj.arguments.length; i++) {\n                exp = substitute(exp, obj.arguments[i], e.arguments[i])\n              }\n              console.log(\"substituted\", exp)\n              return exp; // substituted all arguments.\n\n            }\n            else if (obj.arguments.length > e.arguments.length) {\n              // CALLK\n              stack.push({ kind: \"ApplyToArgs\", arguments: obj.arguments.slice(e.arguments.length, obj.arguments.length) });\n\n              // substitute everything substitutable\n              let exp: Expression = e.f;\n              for (let i = 0; i < e.arguments.length; i++) {\n                exp = substitute(exp, obj.arguments[i], e.arguments[i])\n              }\n              return exp; // substituted all arguments.\n\n            } else if (obj.arguments.length > e.arguments.length) {\n              // PAP2\n              const p = freshVar();\n              heap[p.name] = { kind: \"PAP\", f: e.f, arguments: e.arguments.slice(0, e.arguments.length) };\n              return p;\n            }\n          }\n        } // end switch\n      }\n      return e.f;\n    }\n    case \"Case\": {\n      // push continuation, enter expression\n      stack.push({ kind: \"CaseCont\", alternatives: e.alternatives });\n      return e.expression;\n    }\n  }\n  unreachable(e);\n}\n\nconst atomPrettyPrint = (a: Atom): string => {\n  switch (a.kind) {\n    case \"Literal\": return a.value.toString();\n    case \"Var\": return a.name;\n  }\n}\n\nconst heapPrettyPrint = (key: string, obj: HeapObject): JSX.Element => {\n  switch (obj.kind) {\n    case \"BLACKHOLE\": return <span>{key}: BLACKHOLE</span>;\n    case \"FUN\": return <span>{key}: FUN({obj.arguments.map(x => x.name).join(\" \")})</span>;\n    case \"CON\": return <span>{key}: CON({obj.tag} {obj.payload.map(x => atomPrettyPrint(x)).join(\" \")})</span>;\n    case \"PAP\": return <span>{key}: PAP</span>;\n    case \"THUNK\": return <span>{key}: THUNK ({expressionPrettyPrint(obj.expression)})</span>;\n  }\n}\n\nconst stackPrettyPrint = (cont: Continuation): JSX.Element => {\n  switch (cont.kind) {\n    case \"ApplyToArgs\": return <span>ApplyToArgs</span>;\n    case \"CaseCont\": return (\n      <span>\n        CaseCont <br/>{cont.alternatives.map(\n          branch => (<span className=\"casecont-branch\">{branch.tag} {branch.bindingName.map(y => y.name).join(\" \")} -> ...<br/></span>))}\n      </span>\n    )\n      ;\n    case \"UpdateCont\": return <span>UpdateCont <span className=\"heap-object\">{atomPrettyPrint(cont.var)}</span></span>;\n  }\n}\n\nconst expressionPrettyPrint = (e: Expression): JSX.Element => {\n  switch (e.kind) {\n    case \"Case\": return <span>Case ({expressionPrettyPrint(e.expression)}) of</span>;\n    case \"FunctionApply\": return <span>FunctionApply {atomPrettyPrint(e.f)}</span>;\n    case \"Let\": return <span>Let {e.name} in {heapPrettyPrint(e.name, e.newObject)}</span>;\n    case \"Literal\": return <span>Literal</span>;\n    case \"Var\": return <span>Var {e.name}</span>;\n    case \"PrimPlus\": return <span>{atomPrettyPrint(e.a1)} + {atomPrettyPrint(e.a2)}</span>;\n  }\n}\n\n\nconst App: React.FC = () => {\n  let [step, setStep] = useState(0);\n  let expression: Expression | null = { kind: \"Var\", name: \"main\" };\n\n  // We're re-running all steps up to N each time.\n  heap = mkHeap();\n  varCounter = 0;\n  stack.splice(0, stack.length);\n  for (let i = 0; i < step; i++) {\n    console.log(expression);\n    if (expression == null) break;\n    expression = enter(expression);\n  }\n\n  const backStep = () => { if (step > 0) { setStep(step - 1) } };\n  const forwardStep = () => { if (expression != null) { setStep(step + 1) } }\n\n  const keyPress = (e: React.KeyboardEvent) => {\n    if (e.key === \"ArrowLeft\") {\n      backStep();\n    }\n    if (e.key === \"ArrowRight\") {\n      forwardStep();\n    }\n  }\n  useEffect(() => {\n    window.addEventListener(\"keydown\", keyPress as any);\n    return () => {\n      window.removeEventListener(\"keydown\", keyPress as any);\n    };\n  }, [step])\n\n\n  return (\n    <div className=\"stackheap\">\n      <div className=\"description\">\n        <h2>Spineless Tagless G machine simulator (STG)</h2>\n        <p>Use the left (<span aria-label=\"step back\" role=\"img\">⬅️</span>) and right\n        (<span aria-label=\"step forward\" role=\"img\">➡️</span>) arrow keys to step.</p>\n        <p>This page simulates a very simple version of the STG\n           machine with eval/apply calling conventions.\n        Read the <a href=\"TODO\">blog post</a> for details.\n      </p>\n        <div className=\"step-value\">Step: {step}</div>\n        <div className=\"expression-value\">{expression === null ? null : expressionPrettyPrint(expression)}</div>\n        <hr/>\n        <pre>{`\nnil = CON(Nil);\nzero = CON(I 0);\none = CON(I 1);\ntwo = CON(I 2);\nthree = CON(I 3);\n\nplusInt = FUN(x y ->\n  case x of {\n    I i -> case y of {\n      I j -> case plus# i j of {\n        x -> let { result = CON (I x) } in result }}});\n\nfoldl = FUN(f acc list ->\n  case list of {\n    Nil -> acc;\n    Cons h t -> let {\n      newAcc = THUNK(f acc h)\n    } in foldl f newAcc t\n  });\n\n  # lazy sum with a well-known space leak\n  sum = FUN(list -> foldl plusInt zero list);\n\n  list1 = CON(Cons one nil);\n  list2 = CON(Cons two list1);\n  list3 = CON(Cons three list2);\n\n  main = THUNK(sum list3);\n          `}</pre>\n        <a href=\"https://wiki.haskell.org/Ministg#Source_language\">Program borrowed from here</a>\n      </div>\n      <div className=\"stack\">\n        <h2>Stack</h2>\n        <ul>\n          {stack.map(x => <li>{stackPrettyPrint(x)}</li>)}\n        </ul>\n      </div>\n      <div className=\"heap\">\n        <h2>Heap</h2>\n        <ul>\n          {Object.keys(heap).map(x =>\n            <li className={expression?.kind === \"Var\" ? (expression.name === x ? \"heap-var-active\" : \"\") : \"\"}>\n              {heapPrettyPrint(x, heap[x])}</li>)}\n        </ul>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}